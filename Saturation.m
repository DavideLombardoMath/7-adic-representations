// ========================================================
// This script implements a test to check that a subgroup
// of J(Q) is saturated at some given primes
// ========================================================

load "DivisorReduction.m";

// ========================================================
// BoundIndex
//
// Given a curve X and a list of degree-0 divisors gens on X,
// returns a set of primes q up to Bound1 for which it can
// be proved that the subgroup generated by gens is q-saturated 
// in Jac(X)(Q).
//
// INPUT:
// - X          : smooth projective curve over Q
// - gens       : list of degree-0 divisors on X(Q)
// - TargetList : (optional) list of primes to test for saturation
// - Bound      : (optional) upper bound on the primes p used for
//                reduction [default: 50]. These are the primes
//                for which J(X)(F_p) is used to try and prove
//                saturation
//
// OUTPUT:
// - A set of primes q that do NOT divide the index of <gens> in its
//   saturation inside Jac(X)(Q)
//
// APPROACH:
// - For each small prime q \leq Bound1:
//     - For all linear combinations \sum a_i D_i with a_i \in [0, q-1]
//     - Reduce modulo small primes p
//     - Test whether the resulting divisor class is not divisible by q
//       in Jac(X)(F_p); if so, it is also not divisible by q in J(Q)
//     - If every nonzero \sum a_i D_i is shown to not be divisible by q
//       mod some p, then we conclude q does not divide the index
//
// NOTE:
// - We can always rescale the vector of coefficients (a_1, ..., a_r) by
//   an invertible class modulo q, hence we can assume that a_1 = 0 or 1
//
// ========================================================
function BoundIndex(X, gens : TargetList := [2, 3, 5, 7, 29, 37], Bound := 50)
    NonPrimeDivs := {};
    /*
    Precompute the orders of Jac(X)(F_p) for p up to Bound
    */
    Pic0Orders := AssociativeArray();
    for p in PrimesInInterval(11, Bound) do
	Pic0Orders[p] := JacSize(X, p);
    end for;
    

    for q in TargetList do
        // "Testing prime", q;
        test := true;

        // Generate all nontrivial combinations (a_1,...,a_r) mod q
	if #gens ge 3 then
        	exponents := CartesianProduct([0,1], CartesianPower([0..q-1], #gens-1));
	end if;
        if #gens eq 2 then
            // Optimise this small case by giving an even smaller set of
            // candidate coefficient vectors	
            exponents := [ [0,1], [1,0] ] cat [ [1,i] : i in [1..(q-1)] ];
        end if;
	if #gens eq 1 then
            exponents := [ [1] ]; // with one generator we just need the point itself to not be divisible by q
	end if;

        for e in exponents do
            if test and &+[e[i] : i in [1..#e]] gt 0 then
                // "Testing exponent combination", e;
                localTest := false;

                // Try reductions mod small primes p. The only relevant p are those for which q divides #Jac(X)(F_p)
                for p in [p_red : p_red in PrimesInInterval(11, Bound) | Pic0Orders[p_red] mod q eq 0 ] do
                    // "Reducing mod", p;

                    Xp := ChangeRing(X, GF(p));
                    Dps := [* ReduceDivisor(D, p) : D in gens *];

                    DG := DivisorGroup(Xp);
                    CG, map1, map2 := ClassGroup(Xp);

                    // Map to Pic^0(Xp)
                    DpsPic := [* map2(DG!Numerator(Dp) - DG!Denominator(Dp)) : Dp in Dps *];
                    CG0 := TorsionSubgroup(CG);
                    DpsPic0 := [CG0!x : x in DpsPic];

                    // Compute linear combination and test divisibility by q
                    lincomb := &+[e[i]*DpsPic0[i] : i in [1..#gens]];
                    MultiplesOfq := { q*T : T in CG0 };

                    if not lincomb in MultiplesOfq then
			// "We have shown that the exponent combination", e,
                        // "is not divisible by", q, "modulo", p;
                        localTest := true;
                        break;
                    end if;
                end for;

                test := test and localTest;
            end if;
        end for;

        if test then
            Include(~NonPrimeDivs, q);
        end if;

        // "Primes excluded so far", NonPrimeDivs;
    end for;

    return NonPrimeDivs;
end function;
