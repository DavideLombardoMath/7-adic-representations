// ========================================================
// Auxiliary functions to reduce divisors modulo p
// ========================================================

// ========================================================
// ReduceEffectiveDivisor
//
// Reduce an effective Q-divisor modulo a prime p by taking
// its flat closure over Z and reducing modulo p.
//
// INPUT:
// - D    : an effective divisor on a curve X over Q
// - p    : a rational prime
// - Xred : the reduction mod p of the curve X, defined over F_p
//
// OUTPUT:
// - The reduction of D mod p, as a divisor on Xred.
//
// ========================================================
function ReduceEffectiveDivisor(D, p, Xred)
    IDQ := Ideal(D);                          // Ideal of the effective divisor D over Q
    n := Rank(Parent(Basis(IDQ)[1]));         // Number of variables = dimension of ambient affine/projective space
    RZ := PolynomialRing(Integers(), n);      // Polynomial ring over Z in same variables
    // Clear denominators of the ideal generators to get a Z-model
    IDZ := ideal<RZ | [ClearDenominators(g) : g in Generators(IDQ)]>;
    Ip := ideal<RZ | [p]>;                    // Ideal generated by p in Z
    IDZ := Saturation(IDZ, Ip);               // Saturate to get the flat closure over Z_{(p)}

    Rp := CoordinateRing(AmbientSpace(Xred)); // Coordinate ring of ambient space of Xred
    // Define homomorphism RZ -> Rp reducing coefficients mod p
    h := hom<RZ -> Rp | [Rp.k : k in [1..n]]>;
    // Reduce generators of IDZ mod p
    IDp := ideal<Rp | [ h(g) : g in Generators(IDZ)]>;

    return Divisor(Xred, IDp);                // Construct the reduced divisor on Xred
end function;

// ========================================================
// ReduceDivisor
//
// Reduce an arbitrary Q-divisor modulo a prime p by 
// reducing its numerator and denominator separately.
//
// INPUT:
// - D    : a divisor on a curve X over Q
// - p    : a rational prime
//
// OPTIONAL:
// - Xred : the reduction mod p of the curve X. If not provided,
//          it is computed by reducing the defining equation of X.
//
// OUTPUT:
// - Dred : the reduction of the divisor D mod p, as a divisor on Xred.
//
// DESCRIPTION:
// - If D = D_1 - D_2 (a difference of effective divisors), then
//   ReduceDivisor(D, p) returns
//     ReduceEffectiveDivisor(D_1, p, Xred) - ReduceEffectiveDivisor(D_2, p, Xred).
//
// ========================================================
function ReduceDivisor(D, p : Xred := 0)
    if Xred cmpeq 0 then
        // If no reduction of X is provided, reduce the defining equation
        f := DefiningEquation(Curve(D));        // Equation of X over Q
        f := ClearDenominators(f);              // Get integral equation over Z
        XZ := Curve(ProjectiveSpace(Parent(f)), [f]); // Define X over Z
        Xred := ChangeRing(XZ, GF(p));          // Reduce X mod p
    end if;

    DN := Numerator(D);     // Effective divisor: positive part of D
    DD := Denominator(D);   // Effective divisor: negative part of D
    return ReduceEffectiveDivisor(DN, p, Xred) 
         - ReduceEffectiveDivisor(DD, p, Xred); // Reduce both parts and return the difference
end function;


// ========================================================
// JacSize
//
// Compute the number of F_p-rational points on the Jacobian
// of a curve X/Q with good reduction at p.
//
// INPUT:
// - X : a curve over Q
// - p : a prime number
//
// OUTPUT:
// - The order of Jac(X)(F_p)
//
// ========================================================
function JacSize(X, p)
    CG := ClassGroup(ChangeRing(X, GF(p)));      // compute class group over F_p
    return #TorsionSubgroup(CG);                // return torsion subgroup size (Jacobian)
end function;
