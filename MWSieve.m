// ========================================================
// An implementation of the Mordell-Weil sieve for curves
// whose Jacobian has rank at most 2
// ========================================================

load "DivisorReduction.m";

// ========================================================
// RelationLattice
//
// Compute the lattice of Z-linear relations among given
// generators of a finite abelian group.
//
// INPUT:
// - gens : a sequence of generators of a finite abelian group.
//          Only supported when #gens = 1 or 2.
//
// OUTPUT:
// - The lattice of Z-linear relations among gens.
// - The order of the group generated by gens
//
// WARNING:
// - Only supports 1 or 2 generators.
//
// ========================================================
function RelationLattice(gens)
    assert #gens in {1, 2};

    A := Parent(gens[1]);
    Agen := GenericAbelianGroup(A);
    assert &and[A eq Parent(g) : g in gens];

    gens := [Agen!g : g in gens];
    orders := [Order(g) : g in gens];

    ZZ := IntegerRing();
    M := RSpace(ZZ, #gens);

    // Trivial relations from orders of the generators
    rels := [M | [ (i eq j) select orders[j] else 0 : i in [1..#gens] ] : j in [1..#gens] ];

    if #gens eq 1 then
        M0 := sub<M | rels>;
        return sub<RSpace(Integers(),1) | Basis(M0)>, #(M/M0);
    else
        // Search for further relations among two generators
	// We look for a multiple of D_1 that lies in the
	// subgroup generated by D_2, and conversely
        for d in Divisors(orders[1]) do
            h := d * gens[1];
            try
                a2 := Log(gens[2], -h);
                Append(~rels, M![d, a2 mod orders[2]]);
            catch e // no relation found
                ;
            end try;
        end for;

        for d in Divisors(orders[2]) do
            h := d * gens[2];
            try
                a1 := Log(gens[1], -h);
                Append(~rels, M![a1 mod orders[1], d]);
            catch e	// no relation found
		;
            end try;
        end for;

        M0 := sub<M | rels>;
        return sub<RSpace(Integers(),2) | Basis(M0)>, #(M/M0);
    end if;
end function;


// ========================================================
// CosetsIntersect
//
// Determine whether two cosets in Zⁿ intersect.
//
// INPUT:
// - P1, P2 : points in Zⁿ
// - M1, M2 : finite-index subgroups of Zⁿ
//
// OUTPUT:
// - true iff the cosets P1 + M1 and P2 + M2 intersect
//
// ========================================================
function CosetsIntersect(P1, M1, P2, M2)
    d := OverDimension(M1);
    assert OverDimension(M2) eq d;

    sumLattice := M1 + M2;
    delta := RSpace(Integers(), d)!P1 - RSpace(Integers(), d)!P2;

    return delta in sumLattice;
end function;


// ========================================================
// CompatibleCongruences
//
// Check compatibility of two congruence conditions expressed
// as triples [success, point, sublattice].
//
// INPUT:
// - D1, D2 : triples [Bool, Vec, Lattice] where Vec ∈ ℤⁿ
//
// OUTPUT:
// - true if both success flags are true and the two cosets
//   intersect (i.e., the conditions are compatible)
//
// ========================================================
function CompatibleCongruences(D1, D2)
    success1, P1, M1 := Explode(D1);
    success2, P2, M2 := Explode(D2);

    if not (success1 and success2) then
        return false;
    end if;

    return CosetsIntersect(P1, M1, P2, M2);
end function;


// ========================================================
// DiscreteLogInJacobianFp
//
// Compute a discrete logarithm in the subgroup of Jac(X)(F_p)
// generated by a given set of divisors.
//
// INPUT:
// - Xp               : a curve over F_p
// - P, P0            : rational points on Xp, with P0 as basepoint
// - Dgens            : generators of a subgroup of Jac(Xp)(F_p)
// - LatticeRelations : Z-linear relations among the generators,
//                      given as integer vectors
//
// OUTPUT:
// - A triple [* Bool, Vector, LatticeRelations *], where:
//     - Bool indicates whether (P)-(P0) lies in the span of Dgens
//     - Vector is a Z-linear combination expressing (P)-(P0)
//     - LatticeRelations is passed through unchanged; note that
//       Vector + LatticeRelations is the coset in Z^n giving all
//       possible representations of P-P0 as a linear combination
//       of the generator Dgens
//
// WARNING:
// - Only supports 1 or 2 generators.
//
// ========================================================
function DiscreteLogInJacobianFp(Xp, P, P0, Dgens, LatticeRelations)
    assert #Dgens in {1, 2};

    J, _, map2 := ClassGroup(Curve(P));                     // class group of the curve
    target := map2(Divisor(P)) - map2(Divisor(P0));         // target divisor in Pic^0
    Pic0 := TorsionSubgroup(J);
    target := Pic0!target;

    // Compute orders and lift generators to generic abelian group
    orders := [Order(map2(Numerator(D)) - map2(Denominator(D))) : D in Dgens];
    Dgens := [Pic0!map2(D) : D in Dgens];
    Jgen := GenericAbelianGroup(Pic0);
    Dgens := [Jgen!D : D in Dgens];
    target := Jgen!target;

    if #Dgens eq 1 then

        try
            a := Log(Dgens[1], target);
            assert a * Dgens[1] eq target;
            return [* true, [a], LatticeRelations *];
        catch e	// no logarithm found; will return [* false, dummy values *]
            ;	
        end try;

    else

	// We try to represent target as a1 * D1 + a2 * D2
	// Concretely, we check if target - a1 * D1 admits
	// a discrete logarithm with respect to D2
        for a1 in [0..orders[1]] do
            try
                a2 := Log(Dgens[2], target - a1 * Dgens[1]);
                assert a1 * Dgens[1] + a2 * Dgens[2] eq target;
                return [* true, [a1, a2], LatticeRelations *];
            catch e // try next value
                ;
            end try;
        end for;

    end if;

    return [* false, [0], LatticeRelations *];  // dummy values if P-P0 is not in the span of the generators
end function;



// ========================================================
// MWSieve
//
// Apply the Mordell-Weil sieve at a base prime p and 
// auxiliary primes in a list S.
//
// INPUT:
// - X     : smooth projective curve over Q
// - P0    : base point on X(Q)
// - gens  : list of divisors in Jac(X)(Q)
// - p     : base good prime
// - S     : list of auxiliary good primes
//
// OUTPUT:
// - A list of pairs <P, Dp> where P \in X(F_p) and Dp encodes
//   the discrete log in Jac(X_p), compatible with the existence
// of corresponding F_q-rational points at all primes q in S
//
// ========================================================
function MWSieve(X, P0, gens, p, S : SaturatedPrimes := {})
    assert #gens in {1,2};

    // Step 1: reduce X, P0, and gens mod p
    Xp := ChangeRing(X, GF(p));
    coords := Coordinates(P0);
    coordsp := [GF(p)!(Integers()!c) : c in coords];
    P0p := Xp!coordsp;
    gensp := [ReduceDivisor(D, p : Xred := Xp) : D in gens];

    // Step 2: enumerate X(F_p), keep points mapping into MW subgroup
    points_p := RationalPoints(Xp);
    surviving := [];

    CG, _, map2 := ClassGroup(Xp);
    Pic0 := TorsionSubgroup(CG);
    gensAbstract := [Pic0!map2(g) : g in gensp];
    GensRelations, OrderKnownSubgroup := RelationLattice(gensAbstract);
    // OrderKnownSubgroup is the order of the subgroup of J(F_p) generated
    // by the reductions modulo p of the generators gens. We need to know
    // that this subgroup agrees with the image of J(Q) --> J(F_p). This is
    // known to be true if the index of the KnownSubgroup inside J(F_p) is
    // divisible at most by primes at which we know that the generators are
    // saturated
    // "Primes for which we need saturation", PrimeFactors( Integers()!(#Pic0 / OrderKnownSubgroup) );
    assert PrimeFactors( Integers()!(#Pic0 / OrderKnownSubgroup) ) subset SaturatedPrimes;
    // We collect the orders of the KnownSubgroup to check later that the
    // group generated by the generators gens in the product of the groups
    // J(F_q) for q in S ∪ {p} coincides with the projection of J(Q)
    OKSs:=[OrderKnownSubgroup];

    for P in points_p do
        Dp := DiscreteLogInJacobianFp(Xp, P, P0p, gensp, GensRelations);
        if Dp[1] then
            Append(~surviving, <P, Dp>);
        end if;
    end for;

    // "List of survivors", [ s[1] : s in surviving ];

    // Step 3: sieve each survivor against each auxiliary prime q \in S
    for q in S do
        // print "Sieving at", q;

        // Reduce input data mod q
        Xq := ChangeRing(X, GF(q));
        coordsq := [GF(q)!(Integers()!c) : c in Coordinates(P0)];
        P0q := Xq!coordsq;
        gensq := [ReduceDivisor(D, q : Xred := Xq) : D in gens];

        CG, _, map2 := ClassGroup(Xq);
        Pic0 := TorsionSubgroup(CG);
        gensAbstract := [Pic0!map2(g) : g in gensq];
        GensRelations, OrderKnownSubgroup := RelationLattice(gensAbstract);
        // As above, we test for saturation
        // "Primes for which we need saturation", PrimeFactors( Integers()!(#Pic0 / OrderKnownSubgroup) );
        // We also collect the order of the KnownSubgroup
        assert PrimeFactors( Integers()!(#Pic0 / OrderKnownSubgroup) ) subset SaturatedPrimes;
        Append(~OKSs, OrderKnownSubgroup);

        // Precompute congruences at q
        points_q := RationalPoints(Xq);
        points_q_congruences := [* *];
        for Q in points_q do
            Dq := DiscreteLogInJacobianFp(Xq, Q, P0q, gensq, GensRelations);
            if Dq[1] then
                Append(~points_q_congruences, Dq);
            end if;
        end for;

        // Filter survivors incompatible with q
        for surv in surviving do
            P := surv[1];
            Dp := surv[2];

            compatible_found := exists{ Dq : Dq in points_q_congruences |
                                         CompatibleCongruences(Dp, Dq) };

            if not compatible_found then
                surviving := [pt : pt in surviving | pt[1] ne P];
            end if;
        end for;

        // "Surviving candidates", [ s[1] : s in surviving ];
    end for;

    // Step 4: check that the group generated by the generators gens in
    // the product of the groups J(F_q) for q in S ∪ {p} coincides with 
    // the projection of J(Q)
    PrimesToCheck := 1;
    for i in [1..#OKSs-1] do
        for j in [i+1..#OKSs] do
            PrimesToCheck := PrimesToCheck * GCD(OKSs[i],OKSs[j]);
        end for;
    end for;
    assert PrimeFactors(PrimesToCheck) subset SaturatedPrimes;

    // "----------------";
    return surviving;
end function;
